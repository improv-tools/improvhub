// src/showrunner/shows.api.js
import { supabase } from "lib/supabaseClient";

/* ----------------------------- Series management ---------------------------- */
export async function listMySeries() {
  const { data, error } = await supabase.rpc("list_my_show_series");
  if (error) throw new Error(error.message);
  return data || [];
}

export async function createSeries(name) {
  const { data, error } = await supabase.rpc("create_show_series", { p_name: name });
  if (error) throw new Error(error.message);
  if (Array.isArray(data)) {
    if (!data.length) throw new Error("create_show_series returned no data");
    return data[0];
  }
  if (data && typeof data === 'object') return data;
  throw new Error("create_show_series returned no data");
}

export async function renameSeriesRPC(seriesId, name) {
  const { error } = await supabase.rpc("rename_show_series", { p_series_id: seriesId, p_name: name });
  if (error) throw new Error(error.message);
}

export async function deleteSeriesRPC(seriesId) {
  const { error } = await supabase.rpc("delete_show_series", { p_series_id: seriesId });
  if (error) throw new Error(error.message);
}

/* ---------------------------------- Events ---------------------------------- */
export async function fetchShowEvents(seriesId) {
  const { data, error } = await supabase
    .from("show_events")
    .select("*")
    .eq("series_id", seriesId)
    .order("starts_at", { ascending: true });
  if (error) throw new Error(error.message);
  return data || [];
}

export async function createShowEvent(seriesId, event) {
  const payload = { ...event, series_id: seriesId };
  const { data, error } = await supabase
    .from("show_events")
    .insert(payload)
    .select("*")
    .limit(1);
  if (error) throw new Error(error.message);
  return data?.[0] ?? null;
}

export async function updateShowEvent(eventId, patch) {
  const { data, error } = await supabase.rpc("edit_show_event", { p_event_id: eventId, p_patch: patch });
  if (error) throw new Error(error.message);
  return Array.isArray(data) ? data[0] : data;
}

export async function deleteShowEvent(eventId) {
  const { error } = await supabase.from("show_events").delete().eq("id", eventId);
  if (error) throw new Error(error.message);
}

/* ------------------------------- Occurrence edit ---------------------------- */
export async function fetchShowEventOverrides(seriesId) {
  // Read overrides directly from show_occurrences
  const eventIds = (await supabase.from("show_events").select("id").eq("series_id", seriesId)).data?.map(r => r.id) || [];
  const { data, error } = await supabase
    .from("show_occurrences")
    .select("event_id, base_start, title, description, location, category, tz, starts_at, ends_at, canceled")
    .in("event_id", eventIds);
  if (error) throw new Error(error.message);
  // Map base_start to occ_start for compatibility with callers
  return (data || []).map(r => ({ ...r, occ_start: r.base_start }));
}

export async function patchShowOccurrence(eventId, baseStartIso, patch) {
  // Ensure we only update existing occurrence rows; occurrences should be pre-generated by sync triggers
  const update = { ...patch, canceled: false };
  const { error } = await supabase
    .from("show_occurrences")
    .update(update)
    .eq("event_id", eventId)
    .eq("base_start", baseStartIso);
  if (error) throw new Error(error.message);
}

export async function deleteShowOccurrence(eventId, baseStartIso) {
  const { error } = await supabase
    .from("show_occurrences")
    .update({ canceled: true })
    .eq("event_id", eventId)
    .eq("base_start", baseStartIso);
  if (error) throw new Error(error.message);
}

export async function deleteShowOverride(eventId, baseStartIso) {
  // Clear per-occurrence override fields and reset canceled flag
  const { error } = await supabase
    .from("show_occurrences")
    .update({ title: null, description: null, location: null, category: null, tz: null, starts_at: null, ends_at: null, canceled: false })
    .eq("event_id", eventId)
    .eq("base_start", baseStartIso);
  if (error) throw new Error(error.message);
}

/* ----------------------------------- Lineup ---------------------------------- */
export async function listShowLineup(eventId, baseStartIso) {
  const { data, error } = await supabase
    .rpc("list_show_lineup", { p_event_id: eventId, p_occ_start: baseStartIso });
  if (error) throw new Error(error.message);
  return data || [];
}

export async function inviteTeamToShow(eventId, baseStartIso, teamId) {
  const { error } = await supabase
    .rpc("invite_team_to_show", { p_event_id: eventId, p_occ_start: baseStartIso, p_team_id: teamId });
  if (error) {
    const msg = error?.message || 'Unknown error';
    throw new Error(`Invite team to show failed: ${msg}`);
  }
}

export async function cancelTeamShowInvite(eventId, baseStartIso, teamId) {
  const { error } = await supabase
    .rpc("cancel_team_show_invite", { p_event_id: eventId, p_occ_start: baseStartIso, p_team_id: teamId });
  if (error) {
    const msg = error?.message || 'Unknown error';
    throw new Error(`Cancel invite failed: ${msg}`);
  }
}

export async function resolveTeamIdByDisplayId(displayId) {
  const { data, error } = await supabase.rpc("team_id_by_display_id", { p_display_id: displayId });
  if (error) throw new Error(error.message);
  return data || null; // may be null/undefined if not found
}

export async function removeTeamFromShow(eventId, baseStartIso, teamId) {
  const { error } = await supabase
    .rpc('remove_team_from_show', { p_event_id: eventId, p_occ_start: baseStartIso, p_team_id: teamId });
  if (error) throw new Error(error.message);
}

export async function resolveTeamBriefByDisplayId(displayId) {
  const { data, error } = await supabase.rpc('team_brief_by_display_id', { p_display_id: displayId });
  if (error) throw new Error(error.message);
  if (!data) return null;
  if (Array.isArray(data)) return data[0] || null;
  return data;
}

// Series-level lineup
// Series-level lineup shims (implemented over per-occurrence invites)
export async function listSeriesLineup(eventId) {
  // Distinct teams that have any non-dismissed invite for this event across occurrences
  const { data, error } = await supabase
    .from('show_team_invitations_with_details')
    .select('team_id, team_name, team_display_id, created_at, status')
    .eq('event_id', eventId);
  if (error) throw new Error(error.message);
  const byTeam = new Map();
  (data || []).forEach(r => { if (!byTeam.has(r.team_id)) byTeam.set(r.team_id, r); });
  return Array.from(byTeam.values());
}
export async function inviteTeamToSeries(eventId, teamId) {
  // Invite team to all existing occurrences (max 12 in DB sync window)
  const { data: occs, error: e1 } = await supabase
    .from('show_occurrences')
    .select('base_start, canceled')
    .eq('event_id', eventId);
  if (e1) throw new Error(e1.message);
  const active = (occs || []).filter(o => !o.canceled);
  for (const o of active) {
    const { error } = await supabase.rpc('invite_team_to_show', { p_event_id: eventId, p_occ_start: o.base_start, p_team_id: teamId });
    if (error) throw new Error(error.message);
  }
}
export async function cancelTeamSeriesInvite(eventId, teamId) {
  // Mark canceled across all occurrences where invited
  const { data: rows, error: e1 } = await supabase
    .from('show_team_invitations')
    .select('occ_start')
    .eq('event_id', eventId)
    .eq('team_id', teamId);
  if (e1) throw new Error(e1.message);
  for (const r of (rows || [])) {
    const { error } = await supabase.rpc('cancel_team_show_invite', { p_event_id: eventId, p_occ_start: r.occ_start, p_team_id: teamId });
    if (error) throw new Error(error.message);
  }
}
export async function removeTeamFromSeries(eventId, teamId) {
  // Remove invite rows across all occurrences where present
  const { data: rows, error: e1 } = await supabase
    .from('show_team_invitations')
    .select('occ_start')
    .eq('event_id', eventId)
    .eq('team_id', teamId);
  if (e1) throw new Error(e1.message);
  for (const r of (rows || [])) {
    const { error } = await supabase.rpc('remove_team_from_show', { p_event_id: eventId, p_occ_start: r.occ_start, p_team_id: teamId });
    if (error) throw new Error(error.message);
  }
}

// Occurrence override upsert
export async function upsertOccLineupStatus(eventId, baseStartIso, teamId, status) {
  const { error } = await supabase.rpc('upsert_occ_lineup_status', { p_event_id: eventId, p_occ_start: baseStartIso, p_team_id: teamId, p_status: status });
  if (error) {
    const msg = error?.message || 'Unknown error';
    throw new Error(`Update lineup status failed: ${msg}`);
  }
}

export async function clearOccLineupOverride(eventId, baseStartIso, teamId) {
  const { error } = await supabase.rpc('clear_occ_lineup_override', { p_event_id: eventId, p_occ_start: baseStartIso, p_team_id: teamId });
  if (error) {
    const msg = error?.message || 'Unknown error';
    throw new Error(`Clear lineup override failed: ${msg}`);
  }
}
